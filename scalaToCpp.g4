grammar scalaToCpp;

//tokens
CLASS:	        'class';
OBJECT:         'object';
TRAIT:          'trait';
DEF:            'def';
NEW:            'new';
PRIVATE:        'private';
PUBLIC:         'public';
PROTECTED:      'protected';
LPAREN:	        '(';
RPAREN:	        ')';
LBRACE:	        '{';
RBRACE:	        '}';
COMMA:	        ',';
DOT:	        '.';
EQ:	            '=';
SEMICOLON:	    ';';
COLON:	        ':';
IF:	            'if';
ELSE:	        'else';
WHILE:	        'while';
FOR:	        'for';
RETURN:	        'return';
VAR:	        'var';
VAL:	        'val';
ARROW:	        '<-';
EQEQ:	        '==';
NEQ:	        '!=';
LT:	            '<';
GT:	            '>';
LTEQ:	        '<=';
GTEQ:	        '>=';
PRO:            '%';
AND:	        '&&';
OR:	            '||';
PLUS:	        '+';
MINUS:	        '-';
ASTERISK:	    '*';
SLASH:  	    '/';
BANG:	        '!';
LIST:           'List';
PRINT:          'println';
BOOLEAN_LITERAL: 'true' | 'false';
INT_LITERAL:	[0-9]+;
STRING_LITERAL:	'"' ~('"')* '"';
IDENTIFIER:	[a-zA-Z][a-zA-Z0-9]*;
WS:   [ \t\r\n]+ -> skip;

//productions
plure:	topLevelDef* EOF;
topLevelDef:	classDef | objectDef | traitDef | def;
classDef:	accessModifier? CLASS IDENTIFIER classBody;
accessModifier: PUBLIC | PRIVATE | PROTECTED;
objectDef:	accessModifier? OBJECT IDENTIFIER classBody;
traitDef:	accessModifier? TRAIT IDENTIFIER traitBody;
def:	accessModifier? DEF IDENTIFIER parameterList returnType EQ defBlock;
classBody:	LBRACE classMember* RBRACE;
traitBody:	LBRACE traitMember* RBRACE;
classMember:	classDef | def | assignment SEMICOLON | definition SEMICOLON;
traitMember:	traitDef | def;
parameterList:	LPAREN parameter (COMMA parameter)* RPAREN | LPAREN RPAREN;
parameter:	IDENTIFIER COLON IDENTIFIER;
returnType:	COLON IDENTIFIER | /* epsilon */ ;
defBlock: LBRACE statement* returnVal? RBRACE;
block:	LBRACE statement* RBRACE;
returnVal: RETURN expressionStatement;
statement:	block | ifStatement | whileStatement | forStatement | expressionStatement;
ifStatement:	IF LPAREN logicExpression RPAREN (block | statement) elseStatement?;
elseStatement: ELSE (block | statement);
whileStatement:	WHILE LPAREN logicExpression RPAREN block;
forStatement:	FOR LPAREN (enumeration) RPAREN block;
enumeration:	IDENTIFIER ARROW (expression|listliteral);
expressionStatement:    (expression | printStatement) SEMICOLON;
printStatement: PRINT argumentList;
logicExpression: expression binaryOperator expression | unaryOperator expression | LPAREN expression RPAREN;
expression:	literal | IDENTIFIER | functionCall | objectMethodAccess | assignment | definition;
functionCall:	IDENTIFIER argumentList;
objectMethodAccess:	IDENTIFIER DOT IDENTIFIER argumentList?;
argumentList:	LPAREN (expression (argumentListElement)*)? RPAREN;
argumentListElement:	COMMA expression;
definition: (VAR | VAL |) IDENTIFIER;
assignment: (VAR | VAL |) IDENTIFIER EQ (operation | creation | listliteral);
listliteral: LIST LPAREN (literal | creation | functionCall) (listLiteralElement)*? RPAREN;
listLiteralElement: (COMMA (literal|creation|functionCall));
operation: (IDENTIFIER | literal) (simpleOperator (IDENTIFIER | literal))*;
creation: NEW? functionCall;
binaryOperator:	EQEQ | NEQ | LT | GT | LTEQ | GTEQ | AND | OR | PRO;
unaryOperator:	PLUS | MINUS | BANG;
simpleOperator: PLUS | MINUS | ASTERISK | SLASH;
literal:	BOOLEAN_LITERAL | INT_LITERAL | STRING_LITERAL;